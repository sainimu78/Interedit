1. Done, NiflectGen, CField 改写为 CAccessor, 废弃要求指定NIF_T, 因为设想Accessor可为模板
2. Done, NiflectGen, 可区分出特化类型, 特化类型以直接生成的方式生成代码, 同MyTransform
3. NiflectGen, 重构
	1. AccessorBinding 可定义N维模板
	2. 用通用的流程递归N维Accessor
4. NiflectGen, 为模板类型的 Field 生成代码
	1. 生成如函数模板, 将实例化的模板类型当作一种类型, 用于复用, 同时也能减少编译消耗
	2. 模板实例当作一种类型后, 意味着生成代码流程可统一, 模板实例的 Field 与非模板的 Field 的生成方式类似
	3. 打算以 cursorDecl 为key, 用underlyingType生成模板实例或生成函数名
5. Done, Niflect, 数组型的ElementAccessor改为另外成员, 不与Children混用, 以方便在遍历结构时区分是否为数组型结构
6. Done, Niflect, 概念调整
	1. 概念
		1. Accessor作为结构
		2. Type作为原生类型指针
	2. 作用
		1. 数组型的 Accessor 也为默认的 ArrayAccessor, Type为Native的类型如std::vector<float>
		2. 在反射创建实例时, 通过Type创建Native实例
		3. Accessor 作为一种特定类型, 用于实例序列化
		4. 在查找实例时, 通过入口 ArrayAccessor + 其中的 ElementAccessor 组合查找
7. NiflectGen, Builtin与实例化的模板的StaticGetType只定义在模块范围内, 不为这些类型生成StaticGetType特化导出
8. NiflectGen, Builtin与实例化的模板生成FieldLayout创建函数可统一流程
9. NiflectGen, Builtin与实例化的模板在InitialReg中注册到MiscTable中