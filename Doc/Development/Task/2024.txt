1. Done, NiflectGen, CField 改写为 CAccessor, 废弃要求指定NIF_T, 因为设想Accessor可为模板
2. Done, NiflectGen, 可区分出特化类型, 特化类型以直接生成的方式生成代码, 同MyTransform
3. NiflectGen, 重构
	1. AccessorBinding 可定义N维模板
	2. 用通用的流程递归N维Accessor
4. NiflectGen, 为模板类型的 Field 生成代码
	1. 生成如函数模板, 将实例化的模板类型当作一种类型, 用于复用, 同时也能减少编译消耗
	2. 模板实例当作一种类型后, 意味着生成代码流程可统一, 模板实例的 Field 与非模板的 Field 的生成方式类似
	3. 打算以 cursorDecl 为key, 用underlyingType生成模板实例或生成函数名
5. Done, Niflect, 数组型的ElementAccessor改为另外成员, 不与Children混用, 以方便在遍历结构时区分是否为数组型结构
6. Done, Niflect, 概念调整
	1. 概念
		1. Accessor作为结构
		2. Type作为原生类型指针
	2. 作用
		1. 数组型的 Accessor 也为默认的 ArrayAccessor, Type为Native的类型如std::vector<float>
		2. 在反射创建实例时, 通过Type创建Native实例
		3. Accessor 作为一种特定类型, 用于实例序列化
		4. 在查找实例时, 通过入口 ArrayAccessor + 其中的 ElementAccessor 组合查找
7. NiflectGen, Builtin与实例化的模板的StaticGetType只定义在模块范围内, 不为这些类型生成StaticGetType特化导出
8. NiflectGen, Builtin与实例化的模板生成FieldLayout创建函数可统一流程
9. NiflectGen, Builtin与实例化的模板在InitialReg中注册到MiscTable中
10. Done, NiflectGen, (设想)确认BindingSetting的BindingType与Member的Type是否具有唯一性, 整理一个专门的类处理此繁琐解析过程
11. NiflectGen, Resolve, 遍历所有TaggedType, 收集需要生成的UntaggedType, 如float, TArrayNif
12. NiflectGen, Resolve, AccessorBinding对非1维收集需要生成的UntaggedType, 如pair
	1. 检查成员是否都为public
13. NiflectGen, Resolve, 生成Field类型与m_vecAccessorBindingSetting的查找表, 方便在Write阶段查找
	1. 对于模板嵌套, 需要解析模板实例, 查找每一层模板对应的AccessorBinding, 因此需要考虑是否为特化的完整模板实例生成对应的AccessorBinding索引序列
	2. 向Field类型的别名方向遍历每一级定义是否存在对应的BindingType, 或可只支持一一对应的匹配方式